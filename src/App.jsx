/**
 * App.jsx
 * 
 * Main game component. Handles all phases from vehicle selection through
 * planning (manual or auto) to simulation and results. Keeps track of the
 * player's route, what addresses they've hit, and calculates ESG scores.
 */

// Takes a list of node IDs and finds the edges connecting them in order
function buildEdgeChainFromNodeSequence(nodeSequence, edgeList) {
  if (!nodeSequence || nodeSequence.length < 2) return [];
  const chain = [];
  for (let i = 0; i < nodeSequence.length - 1; i++) {
    const a = nodeSequence[i];
    const b = nodeSequence[i + 1];
    // Direction doesn't matter since the graph is undirected
    const edge = edgeList.find(e => (e.a === a && e.b === b) || (e.a === b && e.b === a));
    if (edge) {
      chain.push(edge);
    }
  }
  return chain;
}
import React, { useState, useMemo, useEffect, useCallback } from 'react'
// Map data: nodes, edges, distances (generated by buildTourSetup.cjs)
import tourSetup from './data/tourSetup.json'
// Baseline metrics for Level 3 to compare against
import baselineMetrics from './data/baselineMetrics.json'
import { vehicles } from './data/vehicles.js'
import MapView from './map/MapView.jsx'
import { simulateRoute } from './game/GameManager.js'
import { clarkeWrightSavings } from './algorithms/clarkeWright.js'
import { findDetour } from './algorithms/pathfinding.js'
import { calculateDistance } from './algorithms/distance.js'
import VehicleSelector from './components/VehicleSelector.jsx'
import ModeSelector from './components/ModeSelector.jsx'
import ESGDashboard from './components/ESGDashboard.jsx'
import TrafficTimeSlider from './components/TrafficTimeSlider.jsx'
import { generateTrafficModel, getTrafficIntensity, getTrafficCategory, calculateTravelTime } from './algorithms/trafficModel.js'
import { euclideanDistance, minutesToHoursAndMinutes } from './utils/mathHelpers.js'

export default function App() {
  const [phase, setPhase] = useState('intro')
  
  const [vehicleId, setVehicleId] = useState(null)
  const [mode, setMode] = useState(null)  // 'manual' or 'auto'
  
  // Manual planning state
  const [manualEdges, setManualEdges] = useState([])
  const [selectedEdgeIds, setSelectedEdgeIds] = useState([])
  const [visitedAddresses, setVisitedAddresses] = useState(new Set())
  const [currentEndNode, setCurrentEndNode] = useState(null)
  const [selectionMessage, setSelectionMessage] = useState(null)
  const [plannedRoute, setPlannedRoute] = useState([])  // may contain blocked edges
  
  // Auto planning state
  const [autoRouteGenerated, setAutoRouteGenerated] = useState(false)
  const [autoGenerating, setAutoGenerating] = useState(false)
  const [autoRouteEdges, setAutoRouteEdges] = useState([])
  const [autoRouteError, setAutoRouteError] = useState(null)
  
  // Adjustment mode: tweak the auto-generated route
  const [adjustingRoute, setAdjustingRoute] = useState(false)
  const [selectedNodesForSwap, setSelectedNodesForSwap] = useState([])
  const [addressSequence, setAddressSequence] = useState([]) // Visit order of delivery addresses
  const [deliveryTimes, setDeliveryTimes] = useState([]) // Arrival times and time windows
  
  // Traffic simulation
  const [trafficModel, setTrafficModel] = useState(null)
  const [currentTime, setCurrentTime] = useState(0) // Minutes from 7:00 AM (range: 0-180)
  
  // Final results after simulation
  const [report, setReport] = useState(null)
  
  // Initialize traffic model when planning phase starts
  useEffect(() => {
    if (phase === 'plan' && !trafficModel) {
      const model = generateTrafficModel(tourSetup.edges)
      setTrafficModel(model)
    }
  }, [phase, trafficModel])

  // Reference metrics for comparison
  const baseline = baselineMetrics.level3
  
  // Node lookup map for fast access
  const nodesById = useMemo(() => {
    const lookup = {}
    tourSetup.nodes.forEach(node => {
      lookup[node.id] = node
    })
    return lookup
  }, [])

  /**
   * Handles overlapping nodes on the map
   * 
   * Some nodes share coordinates (like depot with K02). This lookup helps
   * determine which nodes are at the same physical location, which matters
   * for edge connectivity and address visits.
   * 
   * Returns: { nodeId: [nodeId, overlappingNodeId, ...] }
   */
  const coincidentNodeIds = useMemo(() => {
    const groups = new Map()
    
    // Group nodes by position
    tourSetup.nodes.forEach(node => {
      const key = `${node.x}:${node.y}`
      if (!groups.has(key)) groups.set(key, [])
      groups.get(key).push(node.id)
    })
    
    // Build reverse lookup: each node → all nodes at same position
    const map = {}
    groups.forEach(ids => {
      ids.forEach(id => {
        map[id] = ids
      })
    })
    
    return map
  }, [])

  const depotNode = tourSetup.nodes.find(n => n.type === 'depot')
  const depotId = depotNode?.id
  
  // All nodes at depot position (used to determine valid starting edges)
  const startAnchorIds = useMemo(() => {
    if (!depotNode || !depotId) return []
    return coincidentNodeIds[depotId] ?? [depotId]
  }, [depotNode, depotId, coincidentNodeIds])

  function getCluster(nodeId) {
    if (!nodeId) return []
    return coincidentNodeIds[nodeId] ?? [nodeId]
  }

  function pickPrimaryNode(cluster) {
    if (!cluster || cluster.length === 0) return null
    const hasDepot = cluster.some(id => nodesById[id]?.type === 'depot')
    if (hasDepot) {
      const depotCandidate = cluster.find(id => nodesById[id]?.type === 'depot')
      return depotCandidate ?? cluster[0]
    }
    const addressCandidate = cluster.find(id => nodesById[id]?.type === 'address')
    if (addressCandidate) return addressCandidate
    const junctionCandidate = cluster.find(id => nodesById[id]?.type === 'junction')
    if (junctionCandidate) return junctionCandidate
    return cluster[0]
  }

  function collectVisitedAddresses(cluster, targetSet) {
    cluster.forEach(id => {
      if (nodesById[id]?.type === 'address') targetSet.add(id)
    })
  }

  function handleEdgeSelect(edge) {
    if (mode !== 'manual') return
    if (!depotId) return

    if (manualEdges.length === 0) {
      // First edge must start at depot (or overlapping start node)
      // Check if the selected edge connects to any of the depot's coincident nodes
      const touchesStart = startAnchorIds.includes(edge.a) || startAnchorIds.includes(edge.b)
      if (!touchesStart) {
        setSelectionMessage('Erste Kante muss am Depot starten (Depot teilt sich Koordinaten mit K02).')
        return
      }

      const startId = startAnchorIds.includes(edge.a) ? edge.a : edge.b
      const targetId = edge.a === startId ? edge.b : edge.a

      // Check if addresses are on this edge (including overlapping nodes)
      const newVisited = new Set(visitedAddresses)
      const targetCluster = getCluster(targetId)
      collectVisitedAddresses(targetCluster, newVisited)
      
      const newPrimary = pickPrimaryNode(targetCluster)
      
      const addressesInOrder = []
      targetCluster.forEach(nodeId => {
        const node = nodesById[nodeId]
        if (node && node.type === 'address') {
          addressesInOrder.push(nodeId)
        }
      })
      const deliveryInfo = calculateDeliveryTimes(addressesInOrder, [edge], true)
      
      // Update all states in a single batch to avoid multiple re-renders
      setManualEdges([edge])
      setSelectedEdgeIds([edge.id])
      setVisitedAddresses(newVisited)
      setCurrentEndNode(newPrimary)
      setSelectionMessage(null)
      setDeliveryTimes(deliveryInfo)
    } else {
      // Handle subsequent edges - must connect to current position
      const currentCluster = getCluster(currentEndNode)

      // Following edges must connect to current position (including overlapping nodes)
      const connectsToCurrent = currentCluster.some(id => id === edge.a || id === edge.b)

      // If we're at the depot cluster, allow restarting from depot (for return trip)
      const atDepotCluster = currentCluster.some(id => startAnchorIds.includes(id))
      const connectsToDepot = atDepotCluster && (startAnchorIds.includes(edge.a) || startAnchorIds.includes(edge.b))
      
      if (!connectsToCurrent && !connectsToDepot) {
        // Edge doesn't connect - ignore to prevent dead edges
        setSelectionMessage(`Kante ${edge.id} schließt nicht an Position ${currentEndNode} an. Aktuelle Nachbarn: ${currentCluster.join(', ')}`)
        return
      }
      
      const anchorId = connectsToCurrent
        ? (currentCluster.includes(edge.a) ? edge.a : edge.b)
        : (startAnchorIds.includes(edge.a) ? edge.a : edge.b)
      const newEndNode = anchorId === edge.a ? edge.b : edge.a
      
      // Check if new addresses are visited
      const newVisited = new Set(visitedAddresses)
      const arrivalCluster = getCluster(newEndNode)
      collectVisitedAddresses(arrivalCluster, newVisited)
      
      const newPrimary = pickPrimaryNode(arrivalCluster)
      const newEdges = [...manualEdges, edge]
      
      // Allow repeated edges for return trips (same road can be used multiple times)

      const newSelectedIds = [...selectedEdgeIds, edge.id]
      
      // Calculate delivery times for manual route using the updated edges
      // This determines arrival times and time windows for each stop
      // Build ordered list of addresses visited along the route
      const addressesInOrder = []
      const visitedForCalc = new Set()
      let currentPosCalc = depotId
      
      newEdges.forEach((e, idx) => {
        if (idx === 0) {
          const startId = startAnchorIds.includes(e.a) ? e.a : e.b
          const targetId = e.a === startId ? e.b : e.a
          const targetCluster = getCluster(targetId)
          targetCluster.forEach(nodeId => {
            const node = nodesById[nodeId]
            if (node && node.type === 'address' && !visitedForCalc.has(nodeId)) {
              addressesInOrder.push(nodeId)
              visitedForCalc.add(nodeId)
            }
          })
          currentPosCalc = targetId
        } else {
          const currentCluster = getCluster(currentPosCalc)
          const connectsToCurrent = currentCluster.some(id => id === e.a || id === e.b)
          const anchorId = connectsToCurrent
            ? (currentCluster.includes(e.a) ? e.a : e.b)
            : (startAnchorIds.includes(e.a) ? e.a : e.b)
          const newEndNode = anchorId === e.a ? e.b : e.a
          const arrivalCluster = getCluster(newEndNode)
          arrivalCluster.forEach(nodeId => {
            const node = nodesById[nodeId]
            if (node && node.type === 'address' && !visitedForCalc.has(nodeId)) {
              addressesInOrder.push(nodeId)
              visitedForCalc.add(nodeId)
            }
          })
          currentPosCalc = newEndNode
        }
      })
      
      const deliveryInfo = calculateDeliveryTimes(addressesInOrder, newEdges, true)
      
      // Alle States in einem Batch aktualisieren
      setManualEdges(newEdges)
      setSelectedEdgeIds(newSelectedIds)
      setVisitedAddresses(newVisited)
      setCurrentEndNode(newPrimary)
      setSelectionMessage(null)
      setDeliveryTimes(deliveryInfo)
    }
  }

  // Undo the last selected edge and recalculate route state
  function undoLastEdge() {
    if (manualEdges.length === 0) return
    
    // Remove last edge
    const newEdges = manualEdges.slice(0, -1)
    const newSelectedIds = selectedEdgeIds.slice(0, -1)
    
    // Reconstruct visitedAddresses and currentEndNode
    const newVisited = new Set()
    let newCurrentNode = null
    
    if (newEdges.length === 0) {
      // No edges left - back to start
      newCurrentNode = null
    } else {
      // Process all remaining edges
      newEdges.forEach((edge, idx) => {
        if (idx === 0) {
          // First edge
          const startId = startAnchorIds.includes(edge.a) ? edge.a : edge.b
          const targetId = edge.a === startId ? edge.b : edge.a
          const targetCluster = getCluster(targetId)
          collectVisitedAddresses(targetCluster, newVisited)
          newCurrentNode = pickPrimaryNode(targetCluster)
        } else {
          // Subsequent edges
          const prevEdge = newEdges[idx - 1]
          const currentCluster = getCluster(newCurrentNode)
          const connectsToCurrent = currentCluster.some(id => id === edge.a || id === edge.b)
          const anchorId = connectsToCurrent
            ? (currentCluster.includes(edge.a) ? edge.a : edge.b)
            : (startAnchorIds.includes(edge.a) ? edge.a : edge.b)
          const newEndNode = anchorId === edge.a ? edge.b : edge.a
          const arrivalCluster = getCluster(newEndNode)
          collectVisitedAddresses(arrivalCluster, newVisited)
          newCurrentNode = pickPrimaryNode(arrivalCluster)
        }
      })
    }
    
    // Recalculate delivery times after undo
    const addressesInOrder = []
    const visitedForCalc = new Set()
    let currentPosCalc = depotId
    
    newEdges.forEach((e, idx) => {
      if (idx === 0) {
        const startId = startAnchorIds.includes(e.a) ? e.a : e.b
        const targetId = e.a === startId ? e.b : e.a
        const targetCluster = getCluster(targetId)
        targetCluster.forEach(nodeId => {
          const node = nodesById[nodeId]
          if (node && node.type === 'address' && !visitedForCalc.has(nodeId)) {
            addressesInOrder.push(nodeId)
            visitedForCalc.add(nodeId)
          }
        })
        currentPosCalc = targetId
      } else {
        const currentCluster = getCluster(currentPosCalc)
        const connectsToCurrent = currentCluster.some(id => id === e.a || id === e.b)
        const anchorId = connectsToCurrent
          ? (currentCluster.includes(e.a) ? e.a : e.b)
          : (startAnchorIds.includes(e.a) ? e.a : e.b)
        const newEndNode = anchorId === e.a ? e.b : e.a
        const arrivalCluster = getCluster(newEndNode)
        arrivalCluster.forEach(nodeId => {
          const node = nodesById[nodeId]
          if (node && node.type === 'address' && !visitedForCalc.has(nodeId)) {
            addressesInOrder.push(nodeId)
            visitedForCalc.add(nodeId)
          }
        })
        currentPosCalc = newEndNode
      }
    })
    
    const deliveryInfo = calculateDeliveryTimes(addressesInOrder, newEdges, true)
    
    setManualEdges(newEdges)
    setSelectedEdgeIds(newSelectedIds)
    setVisitedAddresses(newVisited)
    setCurrentEndNode(newCurrentNode)
    setSelectionMessage(null)
    setDeliveryTimes(deliveryInfo)
  }

  // Clear entire manual route and return to initial state
  function resetRoute() {
    setManualEdges([])
    setSelectedEdgeIds([])  // Array statt Set
    setVisitedAddresses(new Set())
    setCurrentEndNode(null)
    setSelectionMessage(null)
    setDeliveryTimes([])
  }

  /**
   * Calculates when we arrive at each delivery address
   * 
   * Takes the ordered list of addresses and the route edges, then figures out
   * arrival times accounting for travel time and traffic. Returns info needed
   * for displaying stop numbers and time windows on the map.
   * 
   * Returns: [{ nodeId, stopNumber, arrivalMin, timeWindow }, ...]
   */
  function calculateDeliveryTimes(sequence, edges, isManualPlanning = false) {
    const deliveryTimes = []
    const STOP_TIME_MIN = 7 // Time spent at each delivery
    const CONSTRUCTION_DELAY_MIN = 30 // Penalty for each construction zone passage
    
    // Map arrival time (minutes from 7:00 AM) to delivery time window
    // Windows: 7-8, 8-9, 9-10
    function getTimeWindow(minutes) {
      if (minutes <= 60) return '7-8'
      if (minutes <= 120) return '8-9'
      return '9-10'
    }
    
    if (!sequence || sequence.length === 0) {
      return deliveryTimes
    }
    
    // Calculate actual travel time using traffic model
    let currentTime = 0 // Start at 7:00 AM (minute 0)
    const addressesVisited = new Set()
    
    // Helper: Get all nodes at the same physical location (coincident nodes)
    const getCluster = (nodeId) => {
      const node = nodesById[nodeId]
      if (!node) return [nodeId]
      
      // Find all nodes at the same position
      return tourSetup.nodes
        .filter(n => n.x === node.x && n.y === node.y)
        .map(n => n.id)
    }
    
    // Track which address in sequence we're looking for next
    let nextAddressIndex = 0
    
    // Traverse edges and check for addresses
    edges.forEach((edge) => {
      // Calculate travel time for this edge
      const edgeLength = edge.lengthKm || edge.distance || 0
      let travelTimeMin
      
      if (isManualPlanning) {
        // Manual planning: simple calculation without traffic or construction delays
        travelTimeMin = (edgeLength / 30) * 60 // 30 km/h
      } else {
        // Auto planning: use traffic model
        travelTimeMin = trafficModel 
          ? calculateTravelTime(edge, trafficModel, currentTime, false) // Planning mode
          : (edgeLength / 30) * 60 // Fallback: 30 km/h
      }
      
      currentTime += travelTimeMin
      
      // Add construction delay only in non-manual planning modes
      if (!isManualPlanning && edge.blocked) {
        currentTime += CONSTRUCTION_DELAY_MIN
      }
      
      // Check both endpoints of this edge for addresses
      const nodeA = nodesById[edge.a]
      const nodeB = nodesById[edge.b]
      
      // Check clusters at both ends for addresses
      const clusterA = getCluster(edge.a)
      const clusterB = getCluster(edge.b)
      
      // Check if any address in our sequence is at either endpoint
      // Process addresses in sequence order (not randomly)
      while (nextAddressIndex < sequence.length) {
        const addressId = sequence[nextAddressIndex]
        
        if (addressesVisited.has(addressId)) {
          nextAddressIndex++
          continue
        }
        
        // Check if this address is at one of the endpoints
        const isAtA = clusterA.includes(addressId)
        const isAtB = clusterB.includes(addressId)
        
        if (isAtA || isAtB) {
          addressesVisited.add(addressId)
          
          const stopNumber = nextAddressIndex + 1
          const arrivalMin = Math.round(currentTime)
          const timeWindow = getTimeWindow(arrivalMin)
          
          deliveryTimes.push({
            nodeId: addressId,
            stopNumber,
            arrivalMin,
            timeWindow
          })
          
          // Add stop time after recording arrival
          currentTime += STOP_TIME_MIN
          nextAddressIndex++
        } else {
          // This address is not at this edge, stop looking
          break
        }
      }
    })
    
    return deliveryTimes
  }

  // Handle node click in adjustment mode for swapping delivery order
  function handleNodeClickForSwap(nodeId) {
    if (!adjustingRoute) return
    
    const node = nodesById[nodeId]
    if (!node || node.type !== 'address') return
    
    // Only allow swapping addresses that are part of the current route
    // Check if node is in the sequence
    if (!addressSequence.includes(nodeId)) return
    
    const currentSelection = [...selectedNodesForSwap]
    
    // If node already selected, deselect it
    if (currentSelection.includes(nodeId)) {
      setSelectedNodesForSwap(currentSelection.filter(id => id !== nodeId))
      return
    }
    
    // If less than 2 nodes selected, add this one
    if (currentSelection.length < 2) {
      setSelectedNodesForSwap([...currentSelection, nodeId])
      
      // If now 2 nodes selected, automatically perform the swap
      if (currentSelection.length === 1) {
        swapNodesAndRecalculate(currentSelection[0], nodeId)
      }
    }
  }

  // Swap two delivery stops and recalculate the entire route
  async function swapNodesAndRecalculate(nodeA, nodeB) {
    const indexA = addressSequence.indexOf(nodeA)
    const indexB = addressSequence.indexOf(nodeB)
    
    if (indexA === -1 || indexB === -1) {
      setSelectedNodesForSwap([])
      return
    }
    
    // Swap the two addresses in the delivery sequence
    const newSequence = [...addressSequence]
    newSequence[indexA] = nodeB
    newSequence[indexB] = nodeA
    
    // Recalculate route with new sequence
    // Use same pathfinding logic as generateAutoRoute Phase 3
    setAutoGenerating(true)
    setSelectedNodesForSwap([])
    
    // Use same logic as generateAutoRoute Phase 3
    const edgesForRoute = []
    let currentPos = depotId
    
    // First: depot to first address
    const depotCluster = getCluster(depotId)
    const firstAddrCluster = getCluster(newSequence[0])
    
    let firstEdge = null
    for (const depotNode of depotCluster) {
      for (const targetNode of firstAddrCluster) {
        firstEdge = tourSetup.edges.find(ed =>
          (ed.a === depotNode && ed.b === targetNode) ||
          (ed.b === depotNode && ed.a === targetNode)
        )
        if (firstEdge) break
      }
      if (firstEdge) break
    }
    
    if (firstEdge) {
      edgesForRoute.push(firstEdge)
      currentPos = newSequence[0]
    } else {
      // No direct edge - use pathfinding to find detour
      const fromJunction = depotCluster.find(id => nodesById[id]?.type === 'junction') || depotCluster[0]
      const toJunction = firstAddrCluster.find(id => nodesById[id]?.type === 'junction') || firstAddrCluster[0]
      const path = findDetour(fromJunction, toJunction, new Set())
      if (path && path.length > 0) {
        edgesForRoute.push(...path)
        currentPos = newSequence[0]
      }
    }
    
    // Collect blocked edges (construction zones) to avoid in routing
    const blockedEdgeIds = new Set()
    tourSetup.edges.forEach(e => {
      if (e.blocked) {
        blockedEdgeIds.add(e.id)
      }
    })
    
    // Route between consecutive addresses in the sequence
    for (let i = 1; i < newSequence.length; i++) {
      const from = currentPos
      const to = newSequence[i]
      const fromCluster = getCluster(from)
      const toCluster = getCluster(to)
      
      let directEdge = null
      for (const fromNode of fromCluster) {
        for (const toNode of toCluster) {
          directEdge = tourSetup.edges.find(ed =>
            ((ed.a === fromNode && ed.b === toNode) ||
            (ed.b === fromNode && ed.a === toNode)) &&
            !ed.blocked
          )
          if (directEdge) break
        }
        if (directEdge) break
      }
      
      if (directEdge) {
        edgesForRoute.push(directEdge)
        currentPos = to
      } else {
        const fromJunction = fromCluster.find(id => nodesById[id]?.type === 'junction') || fromCluster[0]
        const toJunction = toCluster.find(id => nodesById[id]?.type === 'junction') || toCluster[0]
        const path = findDetour(fromJunction, toJunction, blockedEdgeIds)
        if (path && path.length > 0) {
          edgesForRoute.push(...path)
          currentPos = to
        }
      }
    }
    
    // Final leg: return to depot from last delivery
    const lastCluster = getCluster(currentPos)
    const depotReturnCluster = getCluster(depotId)
    
    let returnEdge = null
    for (const fromNode of lastCluster) {
      for (const depotNode of depotReturnCluster) {
        returnEdge = tourSetup.edges.find(ed =>
          ((ed.a === fromNode && ed.b === depotNode) ||
          (ed.b === fromNode && ed.a === depotNode)) &&
          !ed.blocked
        )
        if (returnEdge) break
      }
      if (returnEdge) break
    }
    
    if (returnEdge) {
      edgesForRoute.push(returnEdge)
    } else {
      const fromJunction = lastCluster.find(id => nodesById[id]?.type === 'junction') || lastCluster[0]
      const depotJunction = depotReturnCluster.find(id => nodesById[id]?.type === 'junction') || depotReturnCluster[0]
      const path = findDetour(fromJunction, depotJunction, blockedEdgeIds)
      if (path && path.length > 0) {
        edgesForRoute.push(...path)
      }
    }
    
    // Keep all edges including duplicates (route can use same edge multiple times)
    const routeEdges = edgesForRoute
    
    // Calculate total distance for the new route
    // Calculate metrics
    const visited = new Set(newSequence)
    let totalKm = 0
    routeEdges.forEach(edge => {
      const a = nodesById[edge.a]
      const b = nodesById[edge.b]
      if (a && b) {
        const lengthKm = edge.lengthKm || (euclideanDistance(a.x, a.y, b.x, b.y) * 0.01)
        totalKm += lengthKm
      }
    })
    
    // Update all route-related state with the recalculated values
    const edgeIds = routeEdges.map(e => e.id)
    setAutoRouteEdges(routeEdges)
    setSelectedEdgeIds(edgeIds)
    setAddressSequence(newSequence)
    
    // Recalculate delivery times for new sequence
    const deliveryInfo = calculateDeliveryTimes(newSequence, routeEdges, false)
    setDeliveryTimes(deliveryInfo)
    
    setAutoGenerating(false)
  }

  /**
   * Generate optimized route automatically using multiple strategies
   * 
   * Phase 1: Generate candidate routes using Clarke-Wright, Nearest Neighbor, and random sampling
   * Phase 2: Optimize each candidate with Lin-Kernighan-Helsgaun algorithm
   * Phase 3: Map best route to actual edges, handling coincident nodes and blocked edges
   * Phase 4: Calculate metrics and update state
   */
  async function generateAutoRoute() {
    setAutoGenerating(true)
    setAutoRouteError(null)
    
    try {
      // Phase 1: Build initial route candidates
      const startTime1 = performance.now()
      
      const candidates = []
      
      const allAddresses = tourSetup.nodes
        .filter(n => n.type === 'address')
        .map(n => n.id)
      
      // Import network distance calculator for route evaluation
      // Uses actual road network instead of straight-line distance
      const { calculateNetworkDistance } = await import('./algorithms/networkDistance.js')
      const nodesById = {}
      tourSetup.nodes.forEach(n => { nodesById[n.id] = n })
      const depotId = tourSetup.nodes.find(n => n.type === 'depot').id
      
      // Collect blocked edges to avoid them in route planning
      const blockedEdgeIds = new Set()
      tourSetup.edges.forEach(e => {
        if (e.blocked) {
          blockedEdgeIds.add(e.id)
        }
      })
      
      // Strategy 1: Clarke-Wright savings heuristic (classic TSP approach)
      const cwSequence = clarkeWrightSavings(tourSetup)
      candidates.push(cwSequence)
      
      // Strategy 2: Nearest neighbor from each possible starting address
      // Greedy approach that can find different local optima
      for (const startAddr of allAddresses) {
        const route = []
        const remaining = allAddresses.filter(a => a !== startAddr)
        route.push(startAddr)
        
        let current = startAddr
        while (remaining.length > 0) {
          // Find nearest unvisited address
          let nearestDist = Infinity
          let nearestAddr = null
          for (const addr of remaining) {
            const dist = calculateNetworkDistance(current, addr)
            if (dist < nearestDist) {
              nearestDist = dist
              nearestAddr = addr
            }
          }
          route.push(nearestAddr)
          remaining.splice(remaining.indexOf(nearestAddr), 1)
          current = nearestAddr
        }
        candidates.push(route)
      }
      
      // Strategy 3: Random sampling for diversity (helps escape local optima)
      for (let i = 0; i < 2000; i++) {
        const shuffled = [...allAddresses]
        for (let j = shuffled.length - 1; j > 0; j--) {
          const k = Math.floor(Math.random() * (j + 1))
          ;[shuffled[j], shuffled[k]] = [shuffled[k], shuffled[j]]
        }
        candidates.push(shuffled)
      }
      
      const time1 = performance.now() - startTime1
      
      // Phase 2: Optimize candidates with Lin-Kernighan-Helsgaun
      // LKH is a variable-depth k-opt algorithm with candidate sets
      const startTime2 = performance.now()
      
      const optimizedCandidates = []
      
      // Helper: Calculate total network distance for a complete route
      // Includes depot → first address → ... → last address → depot
      const calculateRouteDistance = (route) => {
        let total = calculateNetworkDistance(depotId, route[0])
        for (let i = 0; i < route.length - 1; i++) {
          total += calculateNetworkDistance(route[i], route[i + 1])
        }
        total += calculateNetworkDistance(route[route.length - 1], depotId)
        return total
      }
      
      
      // Import LKH optimization algorithm
      const { linKernighanHelsgaun } = await import('./algorithms/linKernighanHelsgaun.js')
      
      // Track all optimized routes to find global best
      const allRoutes = []
      
      for (let i = 0; i < candidates.length; i++) {
        if (i % 200 === 0 || i === candidates.length - 1) {
        }
        
        let sequence = candidates[i]
        
        // Apply Lin-Kernighan-Helsgaun algorithm
        // This is a variable-depth k-opt with candidate sets and don't-look bits
        sequence = linKernighanHelsgaun(sequence, depotId)
        
        const dist = calculateRouteDistance(sequence)
        allRoutes.push({ sequence: [...sequence], dist })
        
        // Also optimize reversed tour (different topology may lead to different optimum)
        const reversedSequence = [...candidates[i]].reverse()
        const optimizedReversed = linKernighanHelsgaun(reversedSequence, depotId)
        const distReversed = calculateRouteDistance(optimizedReversed)
        allRoutes.push({ sequence: [...optimizedReversed], dist: distReversed })
      }
      
      // Select the route with minimum total distance
      allRoutes.sort((a, b) => a.dist - b.dist)
      const absoluteBest = allRoutes[0]
      
      
      const optimizedSequence = absoluteBest.sequence
      const time2 = performance.now() - startTime2
      
      // Phase 3: Map optimized sequence to actual graph edges
      // Handle coincident nodes and find paths around blocked edges
      const edgesForRoute = []
      let currentPos = depotId
      
      // Route from depot to first address
      // Must check all coincident nodes for possible direct connections
      const depotCluster = getCluster(depotId)
      const firstAddrCluster = getCluster(optimizedSequence[0])
      
      // Try to find direct edge (also via coincident nodes)
      let firstEdge = null
      for (const depotNode of depotCluster) {
        for (const targetNode of firstAddrCluster) {
          firstEdge = tourSetup.edges.find(ed =>
            (ed.a === depotNode && ed.b === targetNode) ||
            (ed.b === depotNode && ed.a === targetNode)
          )
          if (firstEdge) break
        }
        if (firstEdge) break
      }
      
      if (firstEdge) {
        edgesForRoute.push(firstEdge)
        // Update current position by following the edge to the target cluster
        if (firstAddrCluster.includes(firstEdge.a)) {
          currentPos = firstEdge.a
        } else if (firstAddrCluster.includes(firstEdge.b)) {
          currentPos = firstEdge.b
        } else {
          currentPos = firstAddrCluster[0]
        }
      } else {
        // No direct edge found - search for shortest detour
        // Try all combinations between depot and first address clusters
        let bestPath = null
        let bestStartNode = null
        
        for (const depotNode of depotCluster) {
          for (const targetNode of firstAddrCluster) {
            const path = findDetour(depotNode, targetNode, new Set())
            if (path && path.length > 0) {
              if (!bestPath || path.length < bestPath.length) {
                bestPath = path
                bestStartNode = depotNode
              }
            }
          }
        }
        
        if (bestPath && bestPath.length > 0) {
          edgesForRoute.push(...bestPath)
          // Follow the edge chain
          let trackingPos = bestStartNode
          for (const edge of bestPath) {
            if (edge.a === trackingPos) {
              trackingPos = edge.b
            } else if (edge.b === trackingPos) {
              trackingPos = edge.a
            }
          }
          currentPos = trackingPos
        } else {
          // Should never happen if graph is connected
          setAutoRouteError(`Keine Route vom Depot zur ersten Adresse ${optimizedSequence[0]}`)
          setAutoGenerating(false)
          return
        }
      }
      
      // Route between all consecutive addresses in sequence
      for (let i = 1; i < optimizedSequence.length; i++) {
        const from = optimizedSequence[i - 1]
        const to = optimizedSequence[i]
        
        // Use actual current position cluster (may differ from 'from' due to coincident nodes)
        const currentPosCluster = getCluster(currentPos)
        const toCluster = getCluster(to)
        
        // Try to find direct unblocked edge between clusters
        let directEdge = null
        
        for (const fromNode of currentPosCluster) {
          for (const toNode of toCluster) {
            directEdge = tourSetup.edges.find(ed =>
              ((ed.a === fromNode && ed.b === toNode) ||
              (ed.b === fromNode && ed.a === toNode)) &&
              !ed.blocked  // Skip blocked edges
            )
            if (directEdge) {
              break
            }
          }
          if (directEdge) break
        }
        
        if (directEdge) {
          edgesForRoute.push(directEdge)
          // Update position by identifying which endpoint is in the target cluster
          if (toCluster.includes(directEdge.a)) {
            currentPos = directEdge.a
          } else if (toCluster.includes(directEdge.b)) {
            currentPos = directEdge.b
          } else {
            // Fallback: try to find any node in toCluster that connects
            currentPos = toCluster[0]
          }
        } else {
          // No direct edge - find shortest detour path avoiding blocked edges
          let bestPath = null
          let bestStartNode = null
          let bestEndNode = null
          
          for (const fromNode of currentPosCluster) {
            for (const toNode of toCluster) {
              const path = findDetour(fromNode, toNode, blockedEdgeIds)
              if (path && path.length > 0) {
                if (!bestPath || path.length < bestPath.length) {
                  bestPath = path
                  bestStartNode = fromNode
                  bestEndNode = toNode
                }
              }
            }
          }
          
          if (bestPath && bestPath.length > 0) {
            edgesForRoute.push(...bestPath)
            // Track position through the detour by following edges
            let trackingPos = bestStartNode
            for (const edge of bestPath) {
              if (edge.a === trackingPos) {
                trackingPos = edge.b
              } else if (edge.b === trackingPos) {
                trackingPos = edge.a
              } else {
              }
            }
            currentPos = trackingPos
          } else {
            // Graph may be disconnected or all paths blocked
            setAutoRouteError(`Keine Route gefunden zwischen ${from} und ${to}`)
            setAutoGenerating(false)
            return
          }
        }
      }
      
      // Final leg: route from last delivery back to depot
      const lastCluster = getCluster(currentPos)
      const depotReturnCluster = getCluster(depotId)
      // Search for direct unblocked edge back to depot
      let returnEdge = null
      for (const fromNode of lastCluster) {
        for (const depotNode of depotReturnCluster) {
          returnEdge = tourSetup.edges.find(ed =>
            ((ed.a === fromNode && ed.b === depotNode) ||
            (ed.b === fromNode && ed.a === depotNode)) &&
            !ed.blocked  // Skip blocked edges
          )
          if (returnEdge) break
        }
        if (returnEdge) break
      }
      
      if (returnEdge) {
        edgesForRoute.push(returnEdge)
      } else {
        // Find detour back to depot if no direct edge available
        let bestPath = null
        let bestStartNode = null
        let bestEndNode = null
        
        for (const fromNode of lastCluster) {
          for (const depotNode of depotReturnCluster) {
            const path = findDetour(fromNode, depotNode, blockedEdgeIds)
            if (path && path.length > 0) {
              if (!bestPath || path.length < bestPath.length) {
                bestPath = path
                bestStartNode = fromNode
                bestEndNode = depotNode
              }
            }
          }
        }
        
        if (bestPath && bestPath.length > 0) {
          edgesForRoute.push(...bestPath)
          const totalDist = bestPath.reduce((sum, e) => sum + (e.lengthKm || 0), 0)
        } else {
          // Should not happen in connected graph
          setAutoRouteError(`Keine Rückroute zum Depot gefunden`)
          setAutoGenerating(false)
          return
        }
      }
      
      // Phase 4: Calculate route metrics (distance, time, visited addresses)
      const visited = new Set(optimizedSequence)
      
      // Preserve all edges including duplicates (realistic routing)
      // Same road segment can be traversed multiple times
      const routeEdges = edgesForRoute
      
      
      let totalKm = 0
      let driveTimeMin = 0
      let currentTime = 0 // Start at 7:00
      
      // Track addresses visited to add stop times
      const visitedInOrder = []
      
      routeEdges.forEach(edge => {
        const a = nodesById[edge.a]
        const b = nodesById[edge.b]
        if (a && b) {
          const lengthKm = edge.lengthKm || (euclideanDistance(a.x, a.y, b.x, b.y) * 0.01)
          totalKm += lengthKm
          
          // Calculate drive time using traffic model (planning mode - deterministic)
          // Real simulation will use stochastic traffic
          if (trafficModel && trafficModel.edges[edge.id]) {
            const travelTime = calculateTravelTime(edge, trafficModel, currentTime, false) // Planning mode
            driveTimeMin += travelTime
            currentTime += travelTime
          } else {
            // Fallback: 30 km/h
            const travelTime = (lengthKm / 30) * 60
            driveTimeMin += travelTime
            currentTime += travelTime
          }
          
          // Add stop time when visiting addresses (7 minutes per delivery)
          if (a.type === 'address' && optimizedSequence.includes(a.id) && !visitedInOrder.includes(a.id)) {
            visitedInOrder.push(a.id)
            currentTime += 7 // Add 7 min stop time
          }
          if (b.type === 'address' && optimizedSequence.includes(b.id) && !visitedInOrder.includes(b.id)) {
            visitedInOrder.push(b.id)
            currentTime += 7 // Add 7 min stop time
          }
        }
      })
      
      const stopTimeMin = visited.size * 7
      const totalTimeMin = stopTimeMin + driveTimeMin
      
      const baselineKm = 27.00
      const targetKm = 25.00
      
      
      const improvement = baselineKm - totalKm
      const improvementPct = (improvement / baselineKm * 100)
      
      if (totalKm <= targetKm) {
      } else {
      }
      
      // Update all state with the generated route
      const edgeIds = routeEdges.map(e => e.id)
      
      setAutoRouteEdges(routeEdges)
      setSelectedEdgeIds(edgeIds)
      setVisitedAddresses(visited)
      setCurrentEndNode(depotId)
      setAutoRouteGenerated(true)
      setAutoGenerating(false)
      setAddressSequence([...optimizedSequence]) // Save the sequence for manual adjustment
      
      // Calculate detailed delivery info (arrival times, time windows) for map display
      const deliveryInfo = calculateDeliveryTimes(optimizedSequence, routeEdges, false)
      setDeliveryTimes(deliveryInfo)
      
      // Warn if not all addresses were reached
      if (visited.size < 18) {
        const missing = 18 - visited.size
        setAutoRouteError(`Achtung: ${missing} Adresse(n) nicht erreichbar.`)
      }
      
      
    } catch (error) {
      setAutoRouteError(`Fehler: ${error.message}`)
      setAutoGenerating(false)
    }
  }

  // Clear auto-generated route and return to initial planning state
  function resetAutoRoute() {
    setAutoRouteGenerated(false)
    setAutoRouteEdges([])
    setSelectedEdgeIds([])
    setVisitedAddresses(new Set())
    setCurrentEndNode(null)
    setAutoRouteError(null)
  }

  /**
   * Run route simulation with selected vehicle and traffic model
   * Calculates actual delivery times, costs, and ESG metrics
   */
  function runSimulation() {
    const vehicle = vehicles.find(v => v.id === vehicleId)
    if (!vehicle) { 
      alert('Wählen Sie zuerst ein Fahrzeug aus.')
      return 
    }
    
    // Collect edges based on planning mode (manual vs auto)
    let edgesForSim = []
    if (mode === 'manual') {
      edgesForSim = manualEdges
    } else if (mode === 'auto') {
      if (!autoRouteGenerated) {
        alert('Generieren Sie zuerst eine Route.')
        return
      }
        // Auto mode: edge chain is already correctly built in autoRouteEdges
        edgesForSim = autoRouteEdges;
    }
    
    if (edgesForSim.length === 0) {
      alert('Keine Route vorhanden.')
      return
    }
    // Run stochastic simulation with real-time traffic variations
    const isAutoRoute = mode === 'auto'
    const plannedDeliveryTimes = mode === 'manual' ? deliveryTimes : null
    
    const res = simulateRoute(edgesForSim, vehicle, tourSetup, baseline, trafficModel, isAutoRoute, plannedDeliveryTimes)
    setPlannedRoute(edgesForSim)
    setReport(res)
    setPhase('report')
  }

  return (
    <div className="container">
      {phase === 'intro' && (
        <div className="panel">
          <h1>Lernstufe 3: Technologische Unterstützung bei der Planung</h1>
          <div className="story-text">
            <p>
              Sie sind Geschäftsführerin der Vini Augusta GmbH. Mehrere Kunden haben positiv auf das neue Fahrzeug reagiert. Doch Ihre Disponentin berichtet besorgt 
              von umfangreichen Baustellen im Stadtgebiet, die in der Tagespresse angekündigt wurden.
            </p>
            <p>
              Sie befürchtet, dass Lieferungen nicht mehr pünktlich erfolgen können. 
              Deshalb suchen Sie nach einer Routenplanungssoftware, die solche 
              Hindernisse automatisch berücksichtigt.
            </p>
            <p>
              <strong>Ihre Aufgabe:</strong> Planen Sie eine Tour für 18 Kunden im Zustellfenster von 07:00 bis 10:00 Uhr. 
              Nutzen Sie die Software oder planen Sie weiterhin manuell.
            </p>
            <div className="baseline-box">
              <h4>Ausgangswerte (Baseline):</h4>
              <ul>
                <li>Zustellquote: {(baseline.deliveryRate * 100).toFixed(1)}%</li>
                <li>Gesamtdistanz: {baseline.totalDistance} km</li>
                <li>Gesamtkosten: {baseline.totalCost.toFixed(2)} €</li>
                <li>CO₂-Emissionen: {baseline.co2Emissions.toFixed(3)} kg</li>
              </ul>
            </div>
          </div>
          <button className="button primary" onClick={() => setPhase('select')}>Lernstufe starten</button>
        </div>
      )}

      {phase === 'select' && (
        <div className="panel">
          <h2>Fahrzeug wählen</h2>
          <VehicleSelector vehicles={vehicles} value={vehicleId} onChange={setVehicleId} />
          <h2>Planungsmodus</h2>
          <ModeSelector value={mode} onChange={setMode} />
          <button
            className="button"
            onClick={() => setPhase('plan')}
            disabled={!vehicleId || !mode}
          >
            Zur Planung
          </button>
        </div>
      )}

      {phase === 'plan' && mode === 'manual' && (() => {
        const allAddressesVisited = visitedAddresses.size === 18
        const isBackAtDepot = currentEndNode
          ? getCluster(currentEndNode).some(id => startAnchorIds.includes(id))
          : false
        const canStartSimulation = allAddressesVisited && isBackAtDepot

        return (
          <div className="panel">
            <h2>Route planen (manuell)</h2>
            <p>Klicken Sie Kanten nacheinander; die erste muss am Depot starten.</p>
            
            {mode === 'manual' && (
              <>
                <div style={{ 
                  padding: '12px', 
                  marginBottom: '16px', 
                  background: allAddressesVisited && isBackAtDepot ? '#d1fae5' : '#fef3c7',
                  border: `2px solid ${allAddressesVisited && isBackAtDepot ? '#10b981' : '#f59e0b'}`,
                  borderRadius: '8px'
                }}>
                  <strong>Fortschritt:</strong>
                  <div style={{ marginTop: '8px' }}>
                    Besuchte Adressen: <strong>{visitedAddresses.size}/18</strong>
                    {visitedAddresses.size < 18 && ' (noch nicht alle Adressen besucht)'}
                  </div>
                  {visitedAddresses.size === 18 && currentEndNode !== depotId && (
                    <div style={{ marginTop: '4px', color: '#d97706' }}>
                      Fahren Sie zurück zum Depot
                    </div>
                  )}
                  {allAddressesVisited && isBackAtDepot && (
                    <div style={{ marginTop: '4px', color: '#059669' }}>
                      Route vollständig - bereit für Simulation
                    </div>
                  )}
                </div>
                
                {(() => {
                  // Calculate total distance and drive time
                  const nodesById = {}
                  tourSetup.nodes.forEach(n => { nodesById[n.id] = n })
                  
                  let totalKm = 0
                  let totalDriveTimeMin = 0
                  let currentTime = 0 // Start at 7:00
                  
                  manualEdges.forEach(edge => {
                    const a = nodesById[edge.a]
                    const b = nodesById[edge.b]
                    if (a && b) {
                      const lengthKm = edge.lengthKm || (euclideanDistance(a.x, a.y, b.x, b.y) * 0.01)
                      totalKm += lengthKm
                      
                      // Calculate drive time with planning traffic
                      if (trafficModel && trafficModel.edges[edge.id]) {
                        const travelTime = calculateTravelTime(edge, trafficModel, currentTime, false)
                        totalDriveTimeMin += travelTime
                        currentTime += travelTime
                      } else {
                        // Fallback: 30 km/h
                        const travelTime = (lengthKm / 30) * 60
                        totalDriveTimeMin += travelTime
                        currentTime += travelTime
                      }
                    }
                  })
                  
                  const totalTimeMin = totalDriveTimeMin + (visitedAddresses.size * 7)
                  const { hours, minutes } = minutesToHoursAndMinutes(totalTimeMin)
                  
                  return (
                    <div style={{ 
                      display: 'flex', 
                      gap: '12px', 
                      marginBottom: '16px' 
                    }}>
                      <div style={{ 
                        flex: 1,
                        padding: '12px', 
                        background: '#eff6ff',
                        border: '2px solid #3b82f6',
                        borderRadius: '8px',
                        textAlign: 'center'
                      }}>
                        <div style={{ fontSize: '13px', color: '#1e40af', marginBottom: '4px' }}>
                          Gesamtstrecke
                        </div>
                        <div style={{ fontSize: '24px', fontWeight: 'bold', color: '#1e40af' }}>
                          {totalKm.toFixed(2)} km
                        </div>
                      </div>
                      <div style={{ 
                        flex: 1,
                        padding: '12px', 
                        background: '#f0fdf4',
                        border: '2px solid #10b981',
                        borderRadius: '8px',
                        textAlign: 'center'
                      }}>
                        <div style={{ fontSize: '13px', color: '#065f46', marginBottom: '4px' }}>
                          Geschätzte Dauer
                        </div>
                        <div style={{ fontSize: '24px', fontWeight: 'bold', color: '#065f46' }}>
                          {hours > 0 ? `${hours}h ${minutes}min` : `${minutes} min`}
                        </div>
                      </div>
                    </div>
                  )
                })()}
              </>
            )}
            
            <MapView
              tourData={tourSetup}
              mode={mode}
              selectedEdgeIds={selectedEdgeIds}
              visitedAddresses={visitedAddresses}
              currentNode={currentEndNode}
              onSelectEdge={handleEdgeSelect}
              deliveryTimes={deliveryTimes}
              trafficModel={trafficModel}
              currentTime={currentTime}
            />
            
            {mode === 'manual' && selectionMessage && (
              <div
                style={{
                  marginTop: '12px',
                  padding: '10px',
                  borderRadius: '6px',
                  border: '1px solid #f97316',
                  background: 'rgba(251, 191, 36, 0.15)',
                  color: '#9a3412'
                }}
              >
                {selectionMessage}
              </div>
            )}
            <div style={{ display: 'flex', gap: '10px', marginTop: '16px' }}>
              <button
                className="button primary"
                onClick={runSimulation}
                disabled={!canStartSimulation}
                title={!canStartSimulation ? 'Besuchen Sie alle 18 Adressen und kehren Sie zum Depot zurück' : ''}
              >
                Simulation starten
              </button>
              {mode === 'manual' && manualEdges.length > 0 && (
                <>
                  <button
                    className="button"
                    onClick={undoLastEdge}
                    title="Letzte Kante entfernen"
                  >
                    ↶ Rückgängig
                  </button>
                  <button
                    className="button"
                    onClick={resetRoute}
                  >
                    Route zurücksetzen
                  </button>
                </>
              )}
            </div>
          </div>
        )
      })()}

      {phase === 'plan' && mode === 'auto' && (() => {
        return (
          <div className="panel">
            <h2>Route planen (automatisch)</h2>
            <p>Klicken Sie auf "Route generieren", um die optimale Route mit der Routenplanungssoftware zu berechnen.</p>
            
            {!autoRouteGenerated && !autoGenerating && (
              <button 
                className="button primary"
                onClick={generateAutoRoute}
                style={{ marginBottom: '16px' }}
              >
                Route generieren
              </button>
            )}
            
            {autoGenerating && (
              <div style={{
                padding: '16px',
                background: '#eff6ff',
                border: '2px solid #3b82f6',
                borderRadius: '8px',
                marginBottom: '16px',
                textAlign: 'center'
              }}>
                <div style={{ fontSize: '16px', fontWeight: 'bold', color: '#1e40af', marginBottom: '8px' }}>
                  Berechne die Route...
                </div>
              </div>
            )}
            
            {autoRouteError && (
              <div style={{
                padding: '12px',
                background: '#fef2f2',
                border: '2px solid #dc2626',
                borderRadius: '8px',
                marginBottom: '16px',
                color: '#991b1b'
              }}>
                {autoRouteError}
              </div>
            )}
            
            {autoRouteGenerated && (
              <div style={{
                padding: '12px',
                marginBottom: '16px',
                background: visitedAddresses.size === 18 ? '#d1fae5' : '#fef3c7',
                border: `2px solid ${visitedAddresses.size === 18 ? '#10b981' : '#f59e0b'}`,
                borderRadius: '8px'
              }}>
                <strong>Fortschritt:</strong>
                <div style={{ marginTop: '8px' }}>
                  Besuchte Adressen: <strong>{visitedAddresses.size}/18</strong>
                </div>
                {visitedAddresses.size === 18 && (
                  <div style={{ marginTop: '4px', color: '#059669' }}>
                    Route vollständig - bereit für Simulation
                  </div>
                )}
              </div>
            )}
            
            {autoRouteGenerated && autoRouteEdges.length > 0 && (() => {
              let totalKm = 0
              autoRouteEdges.forEach(edge => {
                const a = nodesById[edge.a]
                const b = nodesById[edge.b]
                if (a && b) {
                  const lengthKm = edge.lengthKm ?? calculateDistance(a, b)
                  totalKm += lengthKm
                }
              })
              
              const totalTimeMin = (totalKm / 30) * 60 + (visitedAddresses.size * 7)
              const { hours, minutes } = minutesToHoursAndMinutes(totalTimeMin)
              
              return (
                <div style={{ display: 'flex', gap: '12px', marginBottom: '16px' }}>
                  <div style={{
                    flex: 1,
                    padding: '12px',
                    background: '#eff6ff',
                    border: '2px solid #3b82f6',
                    borderRadius: '8px',
                    textAlign: 'center'
                  }}>
                    <div style={{ fontSize: '13px', color: '#1e40af', marginBottom: '4px' }}>
                      Gesamtstrecke
                    </div>
                    <div style={{ fontSize: '24px', fontWeight: 'bold', color: '#1e40af' }}>
                      {totalKm.toFixed(2)} km
                    </div>
                  </div>
                  <div style={{
                    flex: 1,
                    padding: '12px',
                    background: '#f0fdf4',
                    border: '2px solid #10b981',
                    borderRadius: '8px',
                    textAlign: 'center'
                  }}>
                    <div style={{ fontSize: '13px', color: '#065f46', marginBottom: '4px' }}>
                      Geschätzte Dauer
                    </div>
                    <div style={{ fontSize: '24px', fontWeight: 'bold', color: '#065f46' }}>
                      {hours > 0 ? `${hours}h ${minutes}min` : `${minutes} min`}
                    </div>
                  </div>
                </div>
              )
            })()}
            
            {autoRouteGenerated && !adjustingRoute && (
              <div style={{
                padding: '12px',
                marginBottom: '12px',
                background: '#fef3c7',
                border: '2px solid #f59e0b',
                borderRadius: '8px',
                fontSize: '13px'
              }}>
                <strong>Tipp:</strong> Aktivieren Sie "Route anpassen", um die Reihenfolge der Stops zu ändern. Klicken Sie zwei Adressen an, um sie zu tauschen.
              </div>
            )}
            
            {adjustingRoute && (
              <div style={{
                padding: '12px',
                marginBottom: '12px',
                background: '#dbeafe',
                border: '2px solid #3b82f6',
                borderRadius: '8px',
                fontSize: '13px'
              }}>
                <strong>Anpassungsmodus aktiv:</strong> Klicken Sie zwei Adressen (Häuser) auf der Karte an, um sie zu tauschen.
                {selectedNodesForSwap.length > 0 && (
                  <div style={{ marginTop: '8px', color: '#1e40af' }}>
                    {selectedNodesForSwap.length} von 2 Adressen ausgewählt
                  </div>
                )}
              </div>
            )}
            
            <MapView
              tourData={tourSetup}
              mode={adjustingRoute ? 'adjust' : 'auto'}
              selectedEdgeIds={selectedEdgeIds}
              visitedAddresses={new Set()}
              currentNode={null}
              onSelectEdge={() => {}}
              onNodeClick={adjustingRoute ? handleNodeClickForSwap : null}
              selectedNodes={selectedNodesForSwap}
              detours={[]}
              deliveryTimes={deliveryTimes}
              trafficModel={trafficModel}
              currentTime={currentTime}
            />
            
            {/* Traffic slider - below map in auto mode */}
            {trafficModel && (
              <div style={{ marginTop: '16px' }}>
                <TrafficTimeSlider 
                  currentTime={currentTime} 
                  onChange={setCurrentTime}
                  disabled={false}
                />
              </div>
            )}
            
            <div style={{ display: 'flex', gap: '10px', marginTop: '16px' }}>
              {autoRouteGenerated && !adjustingRoute && (
                <button
                  className="button"
                  onClick={() => setAdjustingRoute(true)}
                  disabled={autoGenerating}
                  style={{ background: '#f59e0b', color: '#fff' }}
                >
                  Route anpassen
                </button>
              )}
              
              {adjustingRoute && (
                <button
                  className="button"
                  onClick={() => {
                    setAdjustingRoute(false)
                    setSelectedNodesForSwap([])
                  }}
                  style={{ background: '#6b7280', color: '#fff' }}
                >
                  Anpassung beenden
                </button>
              )}
              
              <button
                className="button primary"
                onClick={runSimulation}
                disabled={!autoRouteGenerated || autoGenerating || adjustingRoute}
              >
                Simulation starten
              </button>
              
              {autoRouteGenerated && (
                <button
                  className="button"
                  onClick={resetAutoRoute}
                >
                  Route zurücksetzen
                </button>
              )}
            </div>
          </div>
        )
      })()}

      {phase === 'report' && report && (
        <div className="panel">
          <ESGDashboard baseline={baseline} results={report} />
          
          <div className="report-section" style={{ marginTop: '24px' }}>
            <h4>Ihre geplante Route</h4>
            <div style={{ 
              display: 'flex', 
              gap: '16px', 
              marginBottom: '12px', 
              padding: '12px',
              background: '#f8fafc',
              borderRadius: '6px',
              fontSize: '13px'
            }}>
              <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                <div style={{ width: '20px', height: '4px', background: '#3b82f6' }}></div>
                <span>Geplante Route</span>
              </div>
              <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                <div style={{ width: '20px', height: '3px', background: '#dc2626', borderTop: '3px dashed #dc2626' }}></div>
                <span>Baustelle</span>
              </div>
              {report.detours && report.detours.length > 0 && (
                <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                  <div style={{ width: '20px', height: '4px', background: '#f59e0b' }}></div>
                  <span>Umfahrung</span>
                </div>
              )}
            </div>
            <MapView
              tourData={tourSetup}
              mode="view"
              selectedEdgeIds={selectedEdgeIds}
              visitedAddresses={new Set()}
              currentNode={null}
              onSelectEdge={() => {}}
              detours={report.detours || []}
              deliveryTimes={deliveryTimes}
              trafficModel={trafficModel}
              currentTime={currentTime}
              actualDeliveryTimes={report.actualDeliveryTimes || null}
            />
          </div>
          
          <div className="button-group">
            <button className="button secondary" onClick={() => window.location.reload()}>Neu starten</button>
            {report.passed && (
              <button className="button primary">Weiter zu Lernstufe 4</button>
            )}
          </div>
        </div>
      )}
    </div>
  )
}
